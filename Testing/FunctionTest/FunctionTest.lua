--Describes how to compare two abstract data values. Method defined by ComparisonMethod.
export type ComparisonInfo = {
    ComparisonMethod: string,
    ComparisonFunction: (any, any) -> boolean
}

--Describes an expected function return value for testing.
export type TestReturnValue = {
    ExpectedClassName: string,
    ExpectedType: string,
    ExpectedValue: any,
    ComparisonInfo: ComparisonInfo
}

--Describes an expected mutation to an argument used by a function being tested.
export type TestArgumentMutation = {
    ArgumentIdx: number,
    ExpectedValue: any,
    ComparisonInfo: ComparisonInfo
}

--Holds the set of testable behaviours or features of the functions provided
--More options can be added as needed
local TESTABLE_BEHAVIOURS = {
    ArgumentMutationCheck = 1,
    ReturnValueCheck = 2
}

--A set of options for the amount of detail to display when logging FunctionTest usage warnings
local WARNING_LOD_OPTIONS = {
    None = 1,
    MessageOnly = 2,
    FunctionTrace = 3,
    FullTraceback = 4
}

--Module holds a set of methods for running and validating the effects of functions under test.
local FunctionTest = {

    --The methods available for defining equality of two objects.
    ComparisonMethods = {
        Direct = "Direct",          --Comapre the actual and expected argument values directly (==)
        KeyTable = "KeyTable",      --Compare the actual and expected argument values by keys
        Function = "Function"       --Compare the actual and expected argument values by function
    },
    WarningLoD = WARNING_LOD_OPTIONS.MessageOnly,
    WarningLoDOptions = WARNING_LOD_OPTIONS
}

---Create a formatted message for uncaptured errors generated by test functions.
---@param errMsg string
---@param testContext string
---@param testNum number
---@return string
local function _getErrorThrownMessage(errMsg: string, testContext: string, testNum: number)
    return `{testContext} - {testNum} ERR_THROWN: {errMsg}`
end

---Create a formatted message for a mismatch in the number of return values vs the expected number.
---@param expectedNumValues number
---@param actualNumValues number
---@param testContext string
---@param testNum number
---@return string
local function _getMismatchNumReturnValuesMessage(
    expectedNumValues: number, actualNumValues: number, testContext: string, testNum: number)

    return `{testContext} - {testNum} WRONG_NUM_RETURN_VALUES: ` ..
        `Expected - {expectedNumValues} Actual - {actualNumValues}.`
end

---Create a formatted message for misuse of a FunctionTest Module function.
---@param misuseMsg string
---@param functionName string
---@param testContext string (Optional) The context under which this method was invoked.
---@param testNum any (Optional) The test number that generated this error.
---@return string
local function _getModuleMisuseMessage(
    misuseMsg: string, functionName: string, testContext: string, testNum: number)

    return `{testContext} - {testNum} BAD_FUNCTION_CALL: {functionName}: {misuseMsg}`
end

---Create a formatted message for a variable ClassName mismatch.
---@param expectedClassName string
---@param actualClassName string
---@param testContext string
---@param testNum number
local function _getUnexpectedClassNameMessage(expectedClassName: string, actualClassName: string,
    testContext: string, testNum: number)

    return `{testContext} - {testNum} BAD_CLASS_NAME: ` ..
        `Expected - {expectedClassName} Actual - {actualClassName}`
end

---Create a formatted message for a variable type mismatch.
---@param expectedType string
---@param actualType string
---@param testContext string
---@param testNum number
---@return string
local function _getUnexpectedTypeMessage(expectedType: string, actualType: string,
    testContext: string, testNum: number)

    return `{testContext} - {testNum} BAD_TYPE: Expected - {expectedType} Actual - {actualType}`
end

---Create a formatted message for a variable value mismatch.
---@param expectedValue any
---@param actualValue any
---@param testContext string
---@param testNum number
---@return string
local function _getUnexpectedValueMessage(expectedValue: any, actualValue: any,
    testContext: string, testNum: number)

    return `{testContext} - {testNum} BAD_VALUE: Expected - {expectedValue} Actual - {actualValue}`
end

---Create a template error message for a variable value mismatch referenced by key.
---@param expectedKeyName string
---@param expectedKeyValue any
---@param actualKeyValue any
---@param testContext string
---@param testNum number
---@return string
local function _getUnexpectedKeyValueMessage(
    expectedKeyName: string, expectedKeyValue: any, actualKeyValue: any,
    testContext: string, testNum: number)

    return `{testContext} - {testNum} BAD_VALUE: The Key {expectedKeyName} has Value {actualKeyValue} `
        .. `where Expected {expectedKeyValue}`
end

---Compare an expected value against another value using a ComparisonInfo method.
---@param expectedValue any
---@param actualValue any
---@param comparisonInfo table Describes how to compare the two values passed.
---@param testContext string
---@param testNum number
---@return boolean
---@return string
local function compareExpectedValue(
    expectedValue: any, actualValue: any, comparisonInfo: ComparisonInfo,
    testContext: string, testNum: number)

    local valuesMatch = true
    local valueMatchViolation = nil

    if expectedValue == nil then
        error(_getModuleMisuseMessage(
            "Missing argument #1", "compareExpectedValue", testContext, testNum))
    end

    if actualValue == nil then
        error(_getModuleMisuseMessage(
            "Missing argument #2", "compareExpectedValue", testContext, testNum))
    end

    if not comparisonInfo then
        error(_getModuleMisuseMessage(
            "Missing argument #3", "compareExpectedValue", testContext, testNum))
    end

    if comparisonInfo.ComparisonMethod == FunctionTest.ComparisonMethods.Function then

        if not comparisonInfo.ComparisonFunction then
            error(_getModuleMisuseMessage(
                "Malformed argument #3", "compareExpectedValue", testContext, testNum))
        end

        if not comparisonInfo.ComparisonFunction(expectedValue, actualValue) then
            valuesMatch = false
            valueMatchViolation = _getUnexpectedValueMessage(
                expectedValue, actualValue, testContext, testNum)
        end

    elseif comparisonInfo.ComparisonMethod == FunctionTest.ComparisonMethods.KeyTable then
        local didKeyCheckPass = true

        if type(expectedValue) ~= "table" then
            error(_getModuleMisuseMessage(
                "Cannot Compare expectedValue by KeyTable", "compareExpectedValue", testContext, testNum))
        end

        for expectedKeyName, expectedKeyValue in expectedValue do

            if not actualValue[expectedKeyName] or actualValue[expectedKeyName] ~= expectedKeyValue then
                didKeyCheckPass = false
                valueMatchViolation = _getUnexpectedKeyValueMessage(
                    expectedKeyName, expectedKeyValue, actualValue[expectedKeyName], testContext, testNum)
                break
            end
        end

        if not didKeyCheckPass then
            valuesMatch = false
        end

    else

        if actualValue ~= expectedValue then
            valuesMatch = false
            valueMatchViolation = _getUnexpectedValueMessage(
                expectedValue, actualValue, testContext, testNum)
        end
    end

    return valuesMatch, valueMatchViolation
end

---Module provides a set of functions for testing functions according to
---user-defined expectations.
local FunctionTestFuncs = {
    ClassNames = {
        BasePart = "BasePart",
        Folder = "Folder",
        Model = "Model",
    },

    ComparisonMethods = FunctionTest.ComparisonMethods,

    TestTypes = TESTABLE_BEHAVIOURS,

    DataTypes = {
        Boolean = "boolean",
        Function = "function",
        Instance = "Instance",
        Nil = "nil",
        Number = "number",
        String = "string",
        Table = "table",
        Vector2 = "Vector2",
        Vector3 = "Vector3"
    },
}

---Create and return a table formatted as a TestArgumentMutation object. Optional utility function.
---@param argIdx number
---@param expectedValue any
---@param comparisonMethod string
---@param comparisonFunction function
---@return table
function FunctionTestFuncs.CreateTestArgumentMutationObject(argIdx: number, expectedValue: any,
    comparisonMethod: string, comparisonFunction: (any, any) -> boolean)

    if not argIdx then
        error(`Missing argument #1. Number expected.`)
    end

    if type(argIdx) ~= "number" then
        error(`Invalid argument #1. String expected. Got {type(argIdx)}`)
    end

    if comparisonMethod then

        if type(comparisonMethod) ~= "string" then

            if comparisonMethod == FunctionTest.ComparisonMethods.Function then

                if comparisonFunction then

                    if not type(comparisonFunction) == "function" then
                        error(`Invalid argument #4. Function expected. Got {type(comparisonFunction)}.`)
                    end

                else
                    error(
                        `Missing argument #4 when argument #4 is set to ` ..
                        `{FunctionTest.ComparisonMethods.Function}.`)
                end
            end
        else
            error(`Invalid argument #3. String expected. Got {type(comparisonMethod)}.`)
        end

    else
        error(`Missing argument #3. String expected.`)
    end

    return {
        ArgumentIdx = argIdx,
        ExpectedValue = expectedValue,
        ComparisonInfo = {
            ComparisonMethod = comparisonMethod,
            ComparisonFunction = comparisonFunction
        }
    }
end

---Create and return a table formatted as a TestReturnValue object. Optional utility function.
---@param expectedType string
---@param expectedValue any
---@param expectedClassName string
---@param comparisonMethod string
---@param comparisonFunction function
---@return table
function FunctionTestFuncs.CreateTestReturnValueObject(
    expectedType: string, expectedValue: any, expectedClassName: string,
    comparisonMethod: string, comparisonFunction: (any, any) -> boolean)

    if not expectedType then
        error(`Missing argument #1. String expected.`)
    end

    if type(expectedType) ~= "string" then
        error(`Invalid argument #1. String expected. Got {type(expectedType)}`)
    end

    if not expectedClassName and type(expectedValue) ~= type(expectedType) then
        error(`Argument #2 is not same basic type as argument #1 and no className provided.` ..
        `Evaluation with this ReturnValueObject will always be false.`)
    end

    if expectedClassName and type(expectedClassName) ~= "string" then
        error(`Invalid argument #3. String expected. Got {type(expectedClassName)}.`)
    end

    if comparisonMethod then

        if type(comparisonMethod) ~= "string" then

            if comparisonMethod == FunctionTest.ComparisonMethods.Function then

                if comparisonFunction then

                    if not type(comparisonFunction) == "function" then
                        error(`Invalid argument #5. Function expected. Got {type(comparisonFunction)}.`)
                    end

                else
                    error(
                        `Missing argument #5 when argument #4 is set to ` ..
                        `{FunctionTest.ComparisonMethods.Function}.`)
                end
            end
        else
            error(`Invalid argument #4. String expected. Got {type(comparisonMethod)}.`)
        end

    else
        error(`Missing argument #4. String expected.`)
    end

    --Return a table formatted as a TestReturnValue object
    return {
        ExpectedType = expectedType,
        ExpectedValue = expectedValue,
        ExpectedClassName = expectedClassName,
        ComparisonInfo = {
            ComparisonMethod = comparisonMethod,
            ComparisonFunction = comparisonFunction
        }
    }
end

---Run the passed function with any arguments provided and evaluate the resulting argument mutations against those expected.
---@param funcToCall function The function to be invoked and tested
---@param expectedMutations table A list of TestArgumentMutation table objects
---@param funcArgs table The arguments to invoke with the function (optional)
---@param testContext string
---@param testNum number
---@return boolean
---@return string
function FunctionTestFuncs.RunFunctionMutationTest(funcToCall: (any) -> {},
    expectedMutations: {[number]: TestArgumentMutation}, funcArgs: table?, testContext: string, testNum: number)

    local didTestPass = true
    local testViolation = nil

    if not funcToCall then
        error(_getModuleMisuseMessage(
            "Missing argument #1, function expected", "RunFunctionMutationTest", testContext, testNum))
    end

    if type(funcToCall) ~= "function" then
        error(_getModuleMisuseMessage(
            "Invalid argument #1, function expected.", "RunFunctionMutationTest", testContext, testNum))
    end

    if not expectedMutations then
        error(_getModuleMisuseMessage(
            "Missing argument #2, table expected", "RunFunctionMutationTest", testContext, testNum))
    end

    if type(expectedMutations) ~= "table" then
        error(_getModuleMisuseMessage(
            "Invalid argument #2, table expected.", "RunFunctionMutationTest", testContext, testNum))
    end

    testContext = testContext or "Testing"
    testNum = testNum or "#"

    if not funcArgs then
        funcArgs = {}

    elseif type(funcArgs) ~= "table" then
        error(_getModuleMisuseMessage(
            "Invalid argument #3, table expected.", "RunFunctionMutationTest", testContext, testNum))
    end

    funcToCall(table.unpack(funcArgs))

    for _, mutationInfo: TestArgumentMutation in expectedMutations do

        if type(mutationInfo) ~= "table" then
            error(_getModuleMisuseMessage(
                "Invalid argument #2. [number] = table array table type expected",
                "RunFunctionMutationTest", testContext, testNum
            ))
        end

        didTestPass, testViolation = compareExpectedValue(
            mutationInfo.ExpectedValue, funcArgs[mutationInfo.ArgumentIdx],
            mutationInfo.ComparisonInfo, testContext, testNum)

        if not didTestPass then
            break
        end

    end

    return didTestPass, testViolation
end

---Run the passed function with any arguments provided and evaluate the resulting return values against those expected.
---@param funcToCall function
---@param expectedReturnValues table  A list of ExpectedReturnValue table objects
---@param funcArgs table The arguments to invoke with the function (optional)
---@param testContext string
---@param testNum number The test id or index.
---@return boolean
---@return string
function FunctionTestFuncs.RunFunctionReturnTest(funcToCall: (any) -> {}, expectedReturnValues: table,
    funcArgs: table?, testContext: string, testNum: number)

    local didTestPass = true
    local testViolation = nil

    if not funcToCall then
        error(_getModuleMisuseMessage(
            "Missing argument #1, function expected", "RunFunctionReturnTest", testContext, testNum))
    end

    if type(funcToCall) ~= "function" then
        error(_getModuleMisuseMessage(
            "Invalid argument #1, function expected.", "RunFunctionReturnTest", testContext, testNum))
    end

    if type(expectedReturnValues) ~= "table" then
        error(_getModuleMisuseMessage(
            "Invalid argument #2, table expected.", "RunFunctionReturnTest", testContext, testNum))
    end

    testContext = testContext or "Testing"
    testNum = testNum or "#"

    local returnValues = table.pack(funcToCall(table.unpack(funcArgs)))

    if #returnValues ~= #expectedReturnValues then
        didTestPass = false
        testViolation =_getMismatchNumReturnValuesMessage(
            #expectedReturnValues, #returnValues, testContext, testNum)
    else

        for returnValueIdx, returnValue in ipairs(returnValues) do
            local expectedReturnInfo: TestReturnValue = expectedReturnValues[returnValueIdx]
            local returnValueType = typeof(returnValue)

            if type(expectedReturnInfo) ~= "table" then
                error(_getModuleMisuseMessage(
                    "Invalid argument #2. Array-like table expected",
                    "RunFunctionReturnTest", testContext, testNum
                ))
            end

            if not expectedReturnInfo.ExpectedType then
                error(_getModuleMisuseMessage(
                    "Invalid argument #2. Sub-table is missing ExpectedType key",
                    "RunFunctionReturnTest", testContext, testNum
                ))
            end

            if type(expectedReturnInfo.ExpectedType) ~= "string" then
                error(_getModuleMisuseMessage(
                    "Invalid argument #2. Sub-table has invalid ExpectedType key",
                    "RunFunctionReturnTest", testContext, testNum
                ))
            end

            if string.lower(returnValueType) == string.lower(expectedReturnInfo.ExpectedType) then

                if not expectedReturnInfo.ExpectedClassName or
                    expectedReturnInfo.ExpectedClassName == returnValue.ClassName then

                    didTestPass, testViolation = compareExpectedValue(
                        expectedReturnInfo.ExpectedValue, returnValue,
                        expectedReturnInfo.ComparisonInfo, testContext, testNum)

                    if not didTestPass then
                        break
                    end

                else
                    testViolation =_getUnexpectedClassNameMessage(
                        expectedReturnValues[returnValueIdx].ExpectedClassName,
                        returnValue.ClassName, testContext,testNum)

                    didTestPass = false
                    break
                end

            else
                testViolation =_getUnexpectedTypeMessage(
                    expectedReturnValues[returnValueIdx].ExpectedType, returnValueType,
                    testContext, testNum)

                didTestPass = false
                break
            end
        end
    end

    return didTestPass, testViolation
end

---Run the passed function with any arguments provided and evaluate the resulting argument mutations against those expected.
---xpcall is used to catch errors thrown by the function to test
---@param funcToCall function The function to call
---@param expectedMutations table A list of ParamMutation descriptions for the given inputs
---@param funcArgs table The argumnts to the testing function
---@param testContext string The testing context
---@param testNum number The test id or index
---@return boolean
---@return string
function FunctionTestFuncs.RunFunctionMutationTestSafe(funcToCall: (any) -> {}, expectedMutations: table,
    funcArgs: table, testContext: string, testNum: number)

    local invocationError = nil

    testContext = testContext or "Testing"
    testNum = testNum or "#"

    local runSuccess, testSuccess, testViolation = xpcall(

        function()
            return FunctionTestFuncs.RunFunctionMutationTest(
                funcToCall, funcArgs, expectedMutations, testContext, testNum)
        end,

        function(errMsg)
            invocationError = tostring(errMsg)
        end)

    if not runSuccess then
        testSuccess = false
        testViolation = _getErrorThrownMessage(invocationError, testContext, testNum)
    end

    return testSuccess, testViolation
end

---Run the passed function with any arguments provided and evaluate the resulting return values against those expected.
---xpcall is used to catch errors thrown by the function to test
---@param funcToCall function The function to call
---@param expectedReturnInfo table A list of ExpectedReturnValue descriptions for the given inputs
---@param funcArgs table The argumnts to the testing function
---@param testContext string The testing context
---@param testNum number The test id or index
---@return boolean
---@return string
function FunctionTestFuncs.RunFunctionReturnTestSafe(funcToCall: (any) -> {}, expectedReturnInfo: table,
    funcArgs: table,testContext: string, testNum: number)

    local invocationError = nil

    testContext = testContext or "Testing"
    testNum = testNum or "#"

    local runSuccess, testSuccess, testViolation = xpcall(
        function()
            return FunctionTestFuncs.RunFunctionReturnTest(
                funcToCall, funcArgs, expectedReturnInfo, testContext, testNum)
        end,

        function(errMsg)
            invocationError = tostring(errMsg)
        end)

    if not runSuccess then
        testSuccess = false
        testViolation = _getErrorThrownMessage(invocationError, testContext, testNum)
    end

    return testSuccess, testViolation
end

return FunctionTestFuncs