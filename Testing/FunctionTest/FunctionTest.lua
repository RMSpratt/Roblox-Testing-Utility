--Describes how to compare two abstract data values. Method defined by ComparisonMethod.
export type ComparisonInfo = {
    ComparisonMethod: string,
    ComparisonFunction: (any, any) -> boolean
}

--Describes an expected function return value for testing.
export type TestReturnValue = {
    ExpectedClassName: string,
    ExpectedType: string,
    ExpectedValue: any,
    ComparisonInfo: ComparisonInfo
}

--Describes an expected mutation to an argument used by a function being tested.
export type TestArgumentMutation = {
    ParamIdx: number,
    ArgumentType: string,
    ExpectedValue: any,
    ComparisonInfo: ComparisonInfo
}

--Holds the set of testable behaviours or features of the functions provided
--More options can be added as needed
local TESTABLE_BEHAVIOURS = {
    ParamMutationCheck = 1,
    ReturnValueCheck = 2
}

--A set of options for the amount of detail to display when logging FunctionTest usage warnings
local WARNING_LOD_OPTIONS = {
    None = 1,
    MessageOnly = 2,
    FunctionTrace = 3,
    FullTraceback = 4
}

--Module holds a set of methods for running and validating the effects of functions under test.
local FunctionTest = {
    MutationComparisonMethods = {
        Direct = "Direct",          --Comapre the actual and expected argument values directly (==)
        KeyTable = "KeyTable",      --Compare the actual and expected argument values by keys
        Function = "Function"       --Compare the actual and expected argument values by function
    },
    WarningLoD = WARNING_LOD_OPTIONS.MessageOnly,
    WarningLoDOptions = WARNING_LOD_OPTIONS
}

---Create a formatted message for uncaptured errors generated by test functions.
---@param errMsg string
---@param testContext string
---@param testNum number
---@return string
local function _getErrorThrownMessage(errMsg: string, testContext: string, testNum: number)
    return `{testContext} - {testNum} ERR_THROWN: {errMsg}`
end

---Create a formatted message for a mismatch in the number of return values vs the expected number.
---@param expectedNumValues number
---@param actualNumValues number
---@param testContext string
---@param testNum number
---@return string
local function _getMismatchNumReturnValuesMessage(
    expectedNumValues: number, actualNumValues: number, testContext: string, testNum: number)

    return string.format("%s - %s WRONG_NUM_RETURN_VALUES: Expected - %d Actual - %d.",
        testContext, testNum, expectedNumValues, actualNumValues)

end

---Create a formatted message for misuse of a FunctionTest Module function.
---@param misuseMsg string
---@param functionName string
---@param testContext string
---@param testNum number
---@return string
local function _getModuleMisuseMessage(
    misuseMsg: string, functionName: string, testContext: string, testNum: number)
    return `{testContext} - {testNum} BAD_FUNCTION_CALL: {functionName}: {misuseMsg}`
end

---Create a formatted message for a variable ClassName mismatch.
---@param expectedClassName string
---@param actualClassName string
---@param testContext string
---@param testNum number
local function _getUnexpectedClassNameMessage(expectedClassName: string, actualClassName: string,
    testContext: string, testNum: number)

    return string.format(
        "%s - %d BAD_CLASS_NAME: Expected - %s Actual - %s",
        testContext, testNum, expectedClassName, actualClassName)
end

---Create a formatted message for a variable type mismatch.
---@param expectedType string
---@param actualType string
---@param testContext string
---@param testNum number
---@return string
local function _getUnexpectedTypeMessage(expectedType: string, actualType: string,
    testContext: string, testNum: number)

    return `{testContext} - {testNum} BAD_TYPE: Expected - {expectedType} Actual - {actualType}`
end

---Create a formatted message for a variable value mismatch.
---@param expectedValue any
---@param actualValue any
---@param testContext string
---@param testNum number
---@return string
local function _getUnexpectedValueMessage(expectedValue: any, actualValue: any,
    testContext: string, testNum: number)

    return `{testContext} - {testNum} BAD_VALUE: Expected - {expectedValue} Actual - {actualValue}`
end

---Create a template error message for a variable value mismatch referenced by key.
---@param expectedKeyName string
---@param expectedKeyValue any
---@param actualKeyValue any
---@param testContext string
---@param testNum number
---@return string
local function _getUnexpectedKeyValueMessage(
    expectedKeyName: string, expectedKeyValue: any, actualKeyValue: any,
    testContext: string, testNum: number)

    return `{testContext} - {testNum} BAD_VALUE: The Key {expectedKeyName} has Value {actualKeyValue} `
        .. `where Expected {expectedKeyValue}`
end

---Compare an expected value against another value using a ComparisonInfo method.
---@param expectedValue any
---@param actualValue any
---@param comparisonInfo table Describes how to compare the two values passed.
---@param testContext string
---@param testNum number
---@return boolean
---@return string
local function compareExpectedValue(
    expectedValue: any, actualValue: any, comparisonInfo: ComparisonInfo,
    testContext: string, testNum: number)

    local valuesMatch = true
    local valueMatchViolation = nil

    if expectedValue == nil then
        error(_getModuleMisuseMessage(
            "Missing argument #1", "compareExpectedValue", testContext, testNum))
    end

    if actualValue == nil then
        error(_getModuleMisuseMessage(
            "Missing argument #2", "compareExpectedValue", testContext, testNum))
    end

    if not comparisonInfo then
        error(_getModuleMisuseMessage(
            "Missing argument #3", "compareExpectedValue", testContext, testNum))
    end

    if comparisonInfo.ComparisonMethod == FunctionTest.MutationComparisonMethods.Function then

        if not comparisonInfo.ComparisonFunction then
            error(_getModuleMisuseMessage(
                "Malformed argument #3", "compareExpectedValue", testContext, testNum))
        end

        if not comparisonInfo.ComparisonFunction(expectedValue, actualValue) then
            valuesMatch = false
            valueMatchViolation = _getUnexpectedValueMessage(
                expectedValue, actualValue, testContext, testNum)
        end

    elseif comparisonInfo.ComparisonMethod == FunctionTest.MutationComparisonMethods.KeyTable then
        local didKeyCheckPass = true

        if type(expectedValue) ~= "table" then
            error(_getModuleMisuseMessage(
                "Cannot Compare expectedValue by KeyTable", "compareExpectedValue", testContext, testNum))
        end

        for expectedKeyName, expectedKeyValue in expectedValue do

            if not actualValue[expectedKeyName] or actualValue[expectedKeyName] ~= expectedKeyValue then
                didKeyCheckPass = false
                valueMatchViolation = _getUnexpectedKeyValueMessage(
                    expectedKeyName, expectedKeyValue, actualValue[expectedKeyName], testContext, testNum)
                break
            end
        end

        if not didKeyCheckPass then
            valuesMatch = false
        end

    else

        if actualValue ~= expectedValue then
            valuesMatch = false
            valueMatchViolation = _getUnexpectedValueMessage(
                expectedValue, actualValue, testContext, testNum)
        end
    end

    return valuesMatch, valueMatchViolation
end

---Module provides a set of functions for testing functions according to
---user-defined expectations.
local FunctionTestFuncs = {
    ClassNames = {
        BasePart = "BasePart",
        Folder = "Folder",
        Model = "Model",
    },

    MutationComparisonMethods = FunctionTest.MutationComparisonMethods,

    TestTypes = TESTABLE_BEHAVIOURS,

    DataTypes = {
        Boolean = "boolean",
        Function = "function",
        Instance = "Instance",
        Nil = "nil",
        Number = "number",
        String = "string",
        Table = "table",
        Vector2 = "Vector2",
        Vector3 = "Vector3"
    },
}

---Run the passed function with any arguments provided and evaluate the resulting argument mutations against those expected.
---@param funcToCall function The function to be invoked and tested
---@param expectedMutations table A list of TestArgumentMutation table objects
---@param funcArgs table The arguments to invoke with the function (optional)
---@param testContext string
---@param testNum number
---@return boolean
---@return string
function FunctionTestFuncs.RunFunctionMutationTest(funcToCall: (any) -> {},
    expectedMutations: {[number]: TestArgumentMutation}, funcArgs: table?, testContext: string, testNum: number)

    local didTestPass = true
    local testViolation = nil

    if not funcToCall then
        error(_getModuleMisuseMessage(
            "Missing argument #1, function expected", "RunFunctionMutationTest", testContext, testNum))
    end

    if type(funcToCall) ~= "function" then
        error(_getModuleMisuseMessage(
            "Invalid argument #1, function expected.", "RunFunctionMutationTest", testContext, testNum))
    end

    if not expectedMutations then
        error(_getModuleMisuseMessage(
            "Missing argument #2, table expected", "RunFunctionMutationTest", testContext, testNum))
    end

    if type(expectedMutations) ~= "table" then
        error(_getModuleMisuseMessage(
            "Invalid argument #2, table expected.", "RunFunctionMutationTest", testContext, testNum))
    end

    testContext = testContext or "Testing"
    testNum = testNum or "#"

    if not funcArgs then
        funcArgs = {}

    elseif type(funcArgs) ~= "table" then
        error(_getModuleMisuseMessage(
            "Invalid argument #3, table expected.", "RunFunctionMutationTest", testContext, testNum))
    end

    funcToCall(table.unpack(funcArgs))

    for _, mutationInfo: TestArgumentMutation in expectedMutations do

        if type(mutationInfo) ~= "table" then
            error(_getModuleMisuseMessage(
                "Invalid argument #2. [number] = table array table type expected",
                "RunFunctionMutationTest", testContext, testNum
            ))
        end

        if not mutationInfo.ArgumentType then
            error(_getModuleMisuseMessage(
                "Invalid argument #2. Sub-table is missing ArgumentType key",
                "RunFunctionMutationTest", testContext, testNum
            ))
        end

        if type(mutationInfo.ArgumentType) ~= "string" then
            error(_getModuleMisuseMessage(
                "Invalid argument #2. Sub-table has invalid ArgumentType key",
                "RunFunctionMutationTest", testContext, testNum
            ))
        end

        --The actual argument value must have the same basic type as the expected value
        if string.lower(mutationInfo.ArgumentType) == string.lower(typeof(funcArgs[mutationInfo.ParamIdx])) then
            didTestPass, testViolation = compareExpectedValue(
                mutationInfo.ExpectedValue, funcArgs[mutationInfo.ParamIdx],
                mutationInfo.ComparisonInfo, testContext, testNum)

            if not didTestPass then
                break
            end

        else
            didTestPass = false
            testViolation = _getUnexpectedTypeMessage(
                mutationInfo.ExpectedValue, funcArgs[mutationInfo.ParamIdx], testContext, testNum)
            break
        end
    end

    return didTestPass, testViolation
end

---Run the passed function with any arguments provided and evaluate the resulting return values against those expected.
---@param funcToCall function
---@param expectedReturnValues table  A list of ExpectedReturnValue table objects
---@param funcArgs table The arguments to invoke with the function (optional)
---@param testContext string
---@param testNum number The test id or index.
---@return boolean
---@return string
function FunctionTestFuncs.RunFunctionReturnTest(funcToCall: (any) -> {}, expectedReturnValues: table,
    funcArgs: table?, testContext: string, testNum: number)

    local didTestPass = true
    local testViolation = nil

    if not funcToCall then
        error(_getModuleMisuseMessage(
            "Missing argument #1, function expected", "RunFunctionReturnTest", testContext, testNum))
    end

    if type(funcToCall) ~= "function" then
        error(_getModuleMisuseMessage(
            "Invalid argument #1, function expected.", "RunFunctionReturnTest", testContext, testNum))
    end

    if type(expectedReturnValues) ~= "table" then
        error(_getModuleMisuseMessage(
            "Invalid argument #2, table expected.", "RunFunctionReturnTest", testContext, testNum))
    end

    testContext = testContext or "Testing"
    testNum = testNum or "#"

    local returnValues = table.pack(funcToCall(table.unpack(funcArgs)))

    if #returnValues ~= #expectedReturnValues then
        didTestPass = false
        testViolation =_getMismatchNumReturnValuesMessage(
            #expectedReturnValues, #returnValues, testContext, testNum)
    else

        for returnValueIdx, returnValue in ipairs(returnValues) do
            local expectedReturnInfo: TestReturnValue = expectedReturnValues[returnValueIdx]
            local returnValueType = typeof(returnValue)

            if type(expectedReturnInfo) ~= "table" then
                error(_getModuleMisuseMessage(
                    "Invalid argument #2. Array-like table expected",
                    "RunFunctionReturnTest", testContext, testNum
                ))
            end

            if not expectedReturnInfo.ExpectedType then
                error(_getModuleMisuseMessage(
                    "Invalid argument #2. Sub-table is missing ExpectedType key",
                    "RunFunctionReturnTest", testContext, testNum
                ))
            end

            if type(expectedReturnInfo.ExpectedType) ~= "string" then
                error(_getModuleMisuseMessage(
                    "Invalid argument #2. Sub-table has invalid ExpectedType key",
                    "RunFunctionReturnTest", testContext, testNum
                ))
            end

            if string.lower(returnValueType) == string.lower(expectedReturnInfo.ExpectedType) then

                if not expectedReturnInfo.ExpectedClassName or
                    expectedReturnInfo.ExpectedClassName == returnValue.ClassName then

                    didTestPass, testViolation = compareExpectedValue(
                        expectedReturnInfo.ExpectedValue, returnValue,
                        expectedReturnInfo.ComparisonInfo, testContext, testNum)

                    if not didTestPass then
                        break
                    end

                else
                    testViolation =_getUnexpectedClassNameMessage(
                        expectedReturnValues[returnValueIdx].ExpectedClassName,
                        returnValue.ClassName, testContext,testNum)

                    didTestPass = false
                    break
                end

            else
                testViolation =_getUnexpectedTypeMessage(
                    expectedReturnValues[returnValueIdx].ExpectedType, returnValueType,
                    testContext, testNum)

                didTestPass = false
                break
            end
        end
    end

    return didTestPass, testViolation
end

---Run the passed function with any arguments provided and evaluate the resulting argument mutations against those expected.
---xpcall is used to catch errors thrown by the function to test
---@param funcToCall function The function to call
---@param expectedMutations table A list of ParamMutation descriptions for the given inputs
---@param funcArgs table The argumnts to the testing function
---@param testContext string The testing context
---@param testNum number The test id or index
---@return boolean
---@return string
function FunctionTestFuncs.RunFunctionMutationTestSafe(funcToCall: (any) -> {}, expectedMutations: table,
    funcArgs: table, testContext: string, testNum: number)

    local invocationError = nil

    testContext = testContext or "Testing"
    testNum = testNum or "#"

    local runSuccess, testSuccess, testViolation = xpcall(

        function()
            return FunctionTestFuncs.RunFunctionMutationTest(
                funcToCall, funcArgs, expectedMutations, testContext, testNum)
        end,

        function(errMsg)
            invocationError = tostring(errMsg)
        end)

    if not runSuccess then
        testSuccess = false
        testViolation = _getErrorThrownMessage(invocationError, testContext, testNum)
    end

    return testSuccess, testViolation
end

---Run the passed function with any arguments provided and evaluate the resulting return values against those expected.
---xpcall is used to catch errors thrown by the function to test
---@param funcToCall function The function to call
---@param expectedReturnInfo table A list of ExpectedReturnValue descriptions for the given inputs
---@param funcArgs table The argumnts to the testing function
---@param testContext string The testing context
---@param testNum number The test id or index
---@return boolean
---@return string
function FunctionTestFuncs.RunFunctionReturnTestSafe(funcToCall: (any) -> {}, expectedReturnInfo: table,
    funcArgs: table,testContext: string, testNum: number)

    local invocationError = nil

    testContext = testContext or "Testing"
    testNum = testNum or "#"

    local runSuccess, testSuccess, testViolation = xpcall(
        function()
            return FunctionTestFuncs.RunFunctionReturnTest(
                funcToCall, funcArgs, expectedReturnInfo, testContext, testNum)
        end,

        function(errMsg)
            invocationError = tostring(errMsg)
        end)

    if not runSuccess then
        testSuccess = false
        testViolation = _getErrorThrownMessage(invocationError, testContext, testNum)
    end

    return testSuccess, testViolation
end

return FunctionTestFuncs